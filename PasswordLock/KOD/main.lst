CCS PCM C Compiler, Version 5.015, 5967               15-May-24 21:20

               Filename:   C:\Users\EROOO\Desktop\Mikro Final\picc\MikroFinal\main.lst

               ROM used:   540 words (7%)
                           Largest free fragment is 2048
               RAM used:   62 (17%) at main() level
                           65 (18%) worst case
               Stack used: 3 locations
               Stack size: 8

*
0000:  MOVLW  01
0001:  MOVWF  0A
0002:  GOTO   163
0003:  NOP
.................... #include <16F877.h> 
.................... //////////// Standard Header file for the PIC16F877 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877 
....................  
.................... #list 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
00E4:  MOVF   58,W
00E5:  MOVWF  7A
00E6:  MOVF   57,W
00E7:  MOVWF  04
00E8:  BCF    03.7
00E9:  BTFSC  7A.0
00EA:  BSF    03.7
00EB:  MOVF   00,W
00EC:  MOVWF  5B
00ED:  MOVF   5A,W
00EE:  MOVWF  7A
00EF:  MOVF   59,W
00F0:  MOVWF  04
00F1:  BCF    03.7
00F2:  BTFSC  7A.0
00F3:  BSF    03.7
00F4:  MOVF   00,W
00F5:  SUBWF  5B,W
00F6:  BTFSS  03.2
00F7:  GOTO   10F
....................       if (*s1 == '\0') 
00F8:  MOVF   58,W
00F9:  MOVWF  7A
00FA:  MOVF   57,W
00FB:  MOVWF  04
00FC:  BCF    03.7
00FD:  BTFSC  7A.0
00FE:  BSF    03.7
00FF:  MOVF   00,F
0100:  BTFSS  03.2
0101:  GOTO   105
....................          return(0); 
0102:  MOVLW  00
0103:  MOVWF  78
0104:  GOTO   127
0105:  MOVF   58,W
0106:  MOVWF  7A
0107:  MOVF   57,W
0108:  INCF   57,F
0109:  BTFSC  03.2
010A:  INCF   58,F
010B:  INCF   59,F
010C:  BTFSC  03.2
010D:  INCF   5A,F
010E:  GOTO   0E4
....................    return((*s1 < *s2) ? -1: 1); 
010F:  MOVF   58,W
0110:  MOVWF  7A
0111:  MOVF   57,W
0112:  MOVWF  04
0113:  BCF    03.7
0114:  BTFSC  58.0
0115:  BSF    03.7
0116:  MOVF   00,W
0117:  MOVWF  5B
0118:  MOVF   5A,W
0119:  MOVWF  7A
011A:  MOVF   59,W
011B:  MOVWF  04
011C:  BCF    03.7
011D:  BTFSC  5A.0
011E:  BSF    03.7
011F:  MOVF   00,W
0120:  SUBWF  5B,W
0121:  BTFSC  03.0
0122:  GOTO   125
0123:  MOVLW  FF
0124:  GOTO   126
0125:  MOVLW  01
0126:  MOVWF  78
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
016C:  BCF    03.5
016D:  CLRF   20
016E:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #fuses xt,nowdt 
.................... #use delay(clock=4MHz) 
*
0004:  MOVLW  5A
0005:  MOVWF  04
0006:  BCF    03.7
0007:  MOVF   00,W
0008:  BTFSC  03.2
0009:  GOTO   018
000A:  MOVLW  01
000B:  MOVWF  78
000C:  CLRF   77
000D:  DECFSZ 77,F
000E:  GOTO   00D
000F:  DECFSZ 78,F
0010:  GOTO   00C
0011:  MOVLW  4A
0012:  MOVWF  77
0013:  DECFSZ 77,F
0014:  GOTO   013
0015:  GOTO   016
0016:  DECFSZ 00,F
0017:  GOTO   00A
0018:  RETURN
....................  
.................... // Define bit addresses for LEDs, LCD, and other components 
.................... #bit led = 0x05.0 
.................... #bit TRIS_led = 0x85.0 
.................... #byte lcd = 0x06 
.................... #byte TRIS_lcd = 0x86 
.................... #bit rs = 0x07.0 
.................... #bit TRIS_rs = 0x87.0 
.................... #bit en = 0x07.1 
.................... #bit TRIS_en = 0x87.1 
.................... #bit relay = 0x07.2 
.................... #bit TRIS_relay = 0x87.2 
.................... #bit C1 = 0x08.0 
.................... #bit C2 = 0x08.1 
.................... #bit C3 = 0x08.2 
.................... #bit R1 = 0x08.3 
.................... #bit R2 = 0x08.4 
.................... #bit R3 = 0x08.5 
.................... #bit R4 = 0x08.6 
.................... #bit TRIS_C1 = 0x88.0 
.................... #bit TRIS_C2 = 0x88.1 
.................... #bit TRIS_C3 = 0x88.2 
.................... #bit TRIS_R1 = 0x88.3 
.................... #bit TRIS_R2 = 0x88.4 
.................... #bit TRIS_R3 = 0x88.5 
.................... #bit TRIS_R4 = 0x88.6 
....................  
.................... // Function prototypes 
.................... void display(unsigned char a, int b);  // LCD subroutine 
.................... void debounce();  
.................... char keypad();                         // Keypad subroutine 
.................... void check();                          // Password check routine 
....................  
.................... // Predefined password 
.................... char password[5] = "0000"; 
*
016F:  MOVLW  30
0170:  MOVWF  22
0171:  MOVWF  23
0172:  MOVWF  24
0173:  MOVWF  25
0174:  CLRF   26
.................... char pswd[5]; 
.................... unsigned char open_msg[15] = "Enter Password"; 
0175:  MOVLW  45
0176:  MOVWF  2C
0177:  MOVLW  6E
0178:  MOVWF  2D
0179:  MOVLW  74
017A:  MOVWF  2E
017B:  MOVLW  65
017C:  MOVWF  2F
017D:  MOVLW  72
017E:  MOVWF  30
017F:  MOVLW  20
0180:  MOVWF  31
0181:  MOVLW  50
0182:  MOVWF  32
0183:  MOVLW  61
0184:  MOVWF  33
0185:  MOVLW  73
0186:  MOVWF  34
0187:  MOVWF  35
0188:  MOVLW  77
0189:  MOVWF  36
018A:  MOVLW  6F
018B:  MOVWF  37
018C:  MOVLW  72
018D:  MOVWF  38
018E:  MOVLW  64
018F:  MOVWF  39
0190:  CLRF   3A
.................... unsigned char welcome_msg[8] = "Welcome"; 
0191:  MOVLW  57
0192:  MOVWF  3B
0193:  MOVLW  65
0194:  MOVWF  3C
0195:  MOVLW  6C
0196:  MOVWF  3D
0197:  MOVLW  63
0198:  MOVWF  3E
0199:  MOVLW  6F
019A:  MOVWF  3F
019B:  MOVLW  6D
019C:  MOVWF  40
019D:  MOVLW  65
019E:  MOVWF  41
019F:  CLRF   42
.................... unsigned char close_msg[15] = "Wrong Password"; 
01A0:  MOVLW  57
01A1:  MOVWF  43
01A2:  MOVLW  72
01A3:  MOVWF  44
01A4:  MOVLW  6F
01A5:  MOVWF  45
01A6:  MOVLW  6E
01A7:  MOVWF  46
01A8:  MOVLW  67
01A9:  MOVWF  47
01AA:  MOVLW  20
01AB:  MOVWF  48
01AC:  MOVLW  50
01AD:  MOVWF  49
01AE:  MOVLW  61
01AF:  MOVWF  4A
01B0:  MOVLW  73
01B1:  MOVWF  4B
01B2:  MOVWF  4C
01B3:  MOVLW  77
01B4:  MOVWF  4D
01B5:  MOVLW  6F
01B6:  MOVWF  4E
01B7:  MOVLW  72
01B8:  MOVWF  4F
01B9:  MOVLW  64
01BA:  MOVWF  50
01BB:  CLRF   51
.................... char c; 
.................... int flag, i, count, j; 
....................  
.................... void main() { 
*
0163:  MOVF   03,W
0164:  ANDLW  1F
0165:  MOVWF  03
0166:  BSF    03.5
0167:  BSF    1F.0
0168:  BSF    1F.1
0169:  BSF    1F.2
016A:  BCF    1F.3
016B:  BCF    03.7
....................     // Set directions of the ports 
....................     TRIS_lcd = 0; 
*
01BC:  BSF    03.5
01BD:  CLRF   06
....................     TRIS_en = 0; 
01BE:  BCF    07.1
....................     TRIS_rs = 0; 
01BF:  BCF    07.0
....................     TRIS_led = 0; 
01C0:  BCF    05.0
....................     TRIS_relay = 0; 
01C1:  BCF    07.2
....................     TRIS_R1 = 0; 
01C2:  BCF    08.3
....................     TRIS_R2 = 0; 
01C3:  BCF    08.4
....................     TRIS_R3 = 0; 
01C4:  BCF    08.5
....................     TRIS_R4 = 0; 
01C5:  BCF    08.6
....................     TRIS_C1 = 1; 
01C6:  BSF    08.0
....................     TRIS_C2 = 1; 
01C7:  BSF    08.1
....................     TRIS_C3 = 1; 
01C8:  BSF    08.2
....................  
....................     count = 0; 
01C9:  BCF    03.5
01CA:  CLRF   55
....................     flag = 0; 
01CB:  CLRF   53
....................  
....................     while(TRUE) { 
....................         c = keypad(); 
01CC:  GOTO   01D
01CD:  MOVF   78,W
01CE:  MOVWF  52
....................         if (c == '*') {  // Initialize condition 
01CF:  MOVF   52,W
01D0:  SUBLW  2A
01D1:  BTFSS  03.2
01D2:  GOTO   1FB
....................             flag = 1;  // Flag set to scan other keys 
01D3:  MOVLW  01
01D4:  MOVWF  53
....................             count = 0; 
01D5:  CLRF   55
....................             display(0x01, 0); 
01D6:  MOVWF  58
01D7:  CLRF   59
01D8:  CALL   0CC
....................             display(0x38, 0); 
01D9:  MOVLW  38
01DA:  MOVWF  58
01DB:  CLRF   59
01DC:  CALL   0CC
....................             display(0x0f, 0); 
01DD:  MOVLW  0F
01DE:  MOVWF  58
01DF:  CLRF   59
01E0:  CALL   0CC
....................             display(0x80, 0); 
01E1:  MOVLW  80
01E2:  MOVWF  58
01E3:  CLRF   59
01E4:  CALL   0CC
....................             for (i = 0; i <= 13; i++) { 
01E5:  CLRF   54
01E6:  MOVF   54,W
01E7:  SUBLW  0D
01E8:  BTFSS  03.0
01E9:  GOTO   1F6
....................                 display(open_msg[i], 1); 
01EA:  MOVLW  2C
01EB:  ADDWF  54,W
01EC:  MOVWF  04
01ED:  BCF    03.7
01EE:  MOVF   00,W
01EF:  MOVWF  57
01F0:  MOVWF  58
01F1:  MOVLW  01
01F2:  MOVWF  59
01F3:  CALL   0CC
01F4:  INCF   54,F
01F5:  GOTO   1E6
....................             } 
....................             display(0xc0, 0); 
01F6:  MOVLW  C0
01F7:  MOVWF  58
01F8:  CLRF   59
01F9:  CALL   0CC
....................         } else if (c == '#') {  // Turning off condition 
01FA:  GOTO   21A
01FB:  MOVF   52,W
01FC:  SUBLW  23
01FD:  BTFSS  03.2
01FE:  GOTO   20A
....................             count = 0; 
01FF:  CLRF   55
....................             relay = 0; 
0200:  BCF    07.2
....................             display(0x01, 0); 
0201:  MOVLW  01
0202:  MOVWF  58
0203:  CLRF   59
0204:  CALL   0CC
....................             display(0x0c, 0); 
0205:  MOVLW  0C
0206:  MOVWF  58
0207:  CLRF   59
0208:  CALL   0CC
....................         } else { 
0209:  GOTO   21A
....................             display('*', 1); 
020A:  MOVLW  2A
020B:  MOVWF  58
020C:  MOVLW  01
020D:  MOVWF  59
020E:  CALL   0CC
....................             pswd[count] = c;  // Storing input in new arrays 
020F:  MOVLW  27
0210:  ADDWF  55,W
0211:  MOVWF  04
0212:  BCF    03.7
0213:  MOVF   52,W
0214:  MOVWF  00
....................             count++; 
0215:  INCF   55,F
....................             if (count > 3) { 
0216:  MOVF   55,W
0217:  SUBLW  03
0218:  BTFSS  03.0
....................                 check(); 
0219:  GOTO   0DB
....................             } 
....................         } 
021A:  GOTO   1CC
....................     } 
.................... } 
....................  
021B:  SLEEP
.................... void display(unsigned char a, int b) { 
....................     lcd = a; 
*
00CC:  MOVF   58,W
00CD:  MOVWF  06
....................     rs = b; 
00CE:  BTFSS  59.0
00CF:  BCF    07.0
00D0:  BTFSC  59.0
00D1:  BSF    07.0
....................     en = 1; 
00D2:  BSF    07.1
....................     delay_ms(10); 
00D3:  MOVLW  0A
00D4:  MOVWF  5A
00D5:  CALL   004
....................     en = 0; 
00D6:  BCF    07.1
....................     delay_ms(10); 
00D7:  MOVLW  0A
00D8:  MOVWF  5A
00D9:  CALL   004
00DA:  RETURN
.................... } 
....................  
.................... char keypad() { 
....................     if (flag == 0) {  // Waiting for Initialization 
*
001D:  MOVF   53,F
001E:  BTFSS  03.2
001F:  GOTO   03C
....................         while(TRUE) { 
....................             R4 = 1; 
0020:  BSF    08.6
....................             R1 = R2 = R3 = 0; 
0021:  BCF    08.5
0022:  BCF    08.4
0023:  BCF    08.3
....................             if (C1 == 1) { 
0024:  BTFSS  08.0
0025:  GOTO   02F
....................                 debounce(); 
0026:  CALL   019
....................                 if (C1 == 1) { 
0027:  BTFSS  08.0
0028:  GOTO   02F
....................                     while (C1 == 1);  // Wait for the key to be released 
0029:  BTFSC  08.0
002A:  GOTO   029
....................                     count = 0; 
002B:  CLRF   55
....................                     return '*'; 
002C:  MOVLW  2A
002D:  MOVWF  78
002E:  GOTO   0C9
....................                 } 
....................             } 
....................             if (C3 == 1) { 
002F:  BTFSS  08.2
0030:  GOTO   03A
....................                 debounce(); 
0031:  CALL   019
....................                 if (C3 == 1) { 
0032:  BTFSS  08.2
0033:  GOTO   03A
....................                     while (C3 == 1);  // Wait for the key to be released 
0034:  BTFSC  08.2
0035:  GOTO   034
....................                     count = 0; 
0036:  CLRF   55
....................                     return '#'; 
0037:  MOVLW  23
0038:  MOVWF  78
0039:  GOTO   0C9
....................                 } 
....................             } 
003A:  GOTO   020
....................         } 
....................     } else if (flag == 1) { 
003B:  GOTO   0C7
003C:  DECFSZ 53,W
003D:  GOTO   0C7
....................         while(TRUE) {  // Keypad scan 
....................             // Check row 1 
....................             R1 = 1; 
003E:  BSF    08.3
....................             R2 = R3 = R4 = 0; 
003F:  BCF    08.6
0040:  BCF    08.5
0041:  BCF    08.4
....................             if (C1 == 1) { 
0042:  BTFSS  08.0
0043:  GOTO   04C
....................                 debounce(); 
0044:  CALL   019
....................                 if (C1 == 1) { 
0045:  BTFSS  08.0
0046:  GOTO   04C
....................                     while (C1 == 1);  // Wait for the key to be released 
0047:  BTFSC  08.0
0048:  GOTO   047
....................                     return '1'; 
0049:  MOVLW  31
004A:  MOVWF  78
004B:  GOTO   0C9
....................                 } 
....................             } 
....................             if (C2 == 1) { 
004C:  BTFSS  08.1
004D:  GOTO   056
....................                 debounce(); 
004E:  CALL   019
....................                 if (C2 == 1) { 
004F:  BTFSS  08.1
0050:  GOTO   056
....................                     while (C2 == 1);  // Wait for the key to be released 
0051:  BTFSC  08.1
0052:  GOTO   051
....................                     return '2'; 
0053:  MOVLW  32
0054:  MOVWF  78
0055:  GOTO   0C9
....................                 } 
....................             } 
....................             if (C3 == 1) { 
0056:  BTFSS  08.2
0057:  GOTO   060
....................                 debounce(); 
0058:  CALL   019
....................                 if (C3 == 1) { 
0059:  BTFSS  08.2
005A:  GOTO   060
....................                     while (C3 == 1);  // Wait for the key to be released 
005B:  BTFSC  08.2
005C:  GOTO   05B
....................                     return '3'; 
005D:  MOVLW  33
005E:  MOVWF  78
005F:  GOTO   0C9
....................                 } 
....................             } 
....................  
....................             // Check row 2 
....................             R2 = 1; 
0060:  BSF    08.4
....................             R1 = R3 = R4 = 0; 
0061:  BCF    08.6
0062:  BCF    08.5
0063:  BCF    08.3
....................             if (C1 == 1) { 
0064:  BTFSS  08.0
0065:  GOTO   06E
....................                 debounce(); 
0066:  CALL   019
....................                 if (C1 == 1) { 
0067:  BTFSS  08.0
0068:  GOTO   06E
....................                     while (C1 == 1);  // Wait for the key to be released 
0069:  BTFSC  08.0
006A:  GOTO   069
....................                     return '4'; 
006B:  MOVLW  34
006C:  MOVWF  78
006D:  GOTO   0C9
....................                 } 
....................             } 
....................             if (C2 == 1) { 
006E:  BTFSS  08.1
006F:  GOTO   078
....................                 debounce(); 
0070:  CALL   019
....................                 if (C2 == 1) { 
0071:  BTFSS  08.1
0072:  GOTO   078
....................                     while (C2 == 1);  // Wait for the key to be released 
0073:  BTFSC  08.1
0074:  GOTO   073
....................                     return '5'; 
0075:  MOVLW  35
0076:  MOVWF  78
0077:  GOTO   0C9
....................                 } 
....................             } 
....................             if (C3 == 1) { 
0078:  BTFSS  08.2
0079:  GOTO   082
....................                 debounce(); 
007A:  CALL   019
....................                 if (C3 == 1) { 
007B:  BTFSS  08.2
007C:  GOTO   082
....................                     while (C3 == 1);  // Wait for the key to be released 
007D:  BTFSC  08.2
007E:  GOTO   07D
....................                     return '6'; 
007F:  MOVLW  36
0080:  MOVWF  78
0081:  GOTO   0C9
....................                 } 
....................             } 
....................  
....................             // Check row 3 
....................             R3 = 1; 
0082:  BSF    08.5
....................             R1 = R2 = R4 = 0; 
0083:  BCF    08.6
0084:  BCF    08.4
0085:  BCF    08.3
....................             if (C1 == 1) { 
0086:  BTFSS  08.0
0087:  GOTO   090
....................                 debounce(); 
0088:  CALL   019
....................                 if (C1 == 1) { 
0089:  BTFSS  08.0
008A:  GOTO   090
....................                     while (C1 == 1);  // Wait for the key to be released 
008B:  BTFSC  08.0
008C:  GOTO   08B
....................                     return '7'; 
008D:  MOVLW  37
008E:  MOVWF  78
008F:  GOTO   0C9
....................                 } 
....................             } 
....................             if (C2 == 1) { 
0090:  BTFSS  08.1
0091:  GOTO   09A
....................                 debounce(); 
0092:  CALL   019
....................                 if (C2 == 1) { 
0093:  BTFSS  08.1
0094:  GOTO   09A
....................                     while (C2 == 1);  // Wait for the key to be released 
0095:  BTFSC  08.1
0096:  GOTO   095
....................                     return '8'; 
0097:  MOVLW  38
0098:  MOVWF  78
0099:  GOTO   0C9
....................                 } 
....................             } 
....................             if (C3 == 1) { 
009A:  BTFSS  08.2
009B:  GOTO   0A4
....................                 debounce(); 
009C:  CALL   019
....................                 if (C3 == 1) { 
009D:  BTFSS  08.2
009E:  GOTO   0A4
....................                     while (C3 == 1);  // Wait for the key to be released 
009F:  BTFSC  08.2
00A0:  GOTO   09F
....................                     return '9'; 
00A1:  MOVLW  39
00A2:  MOVWF  78
00A3:  GOTO   0C9
....................                 } 
....................             } 
....................  
....................             // Check row 4 
....................             R4 = 1; 
00A4:  BSF    08.6
....................             R1 = R2 = R3 = 0; 
00A5:  BCF    08.5
00A6:  BCF    08.4
00A7:  BCF    08.3
....................             if (C1 == 1) { 
00A8:  BTFSS  08.0
00A9:  GOTO   0B2
....................                 debounce(); 
00AA:  CALL   019
....................                 if (C1 == 1) { 
00AB:  BTFSS  08.0
00AC:  GOTO   0B2
....................                     while (C1 == 1);  // Wait for the key to be released 
00AD:  BTFSC  08.0
00AE:  GOTO   0AD
....................                     return '*'; 
00AF:  MOVLW  2A
00B0:  MOVWF  78
00B1:  GOTO   0C9
....................                 } 
....................             } 
....................             if (C2 == 1) { 
00B2:  BTFSS  08.1
00B3:  GOTO   0BC
....................                 debounce(); 
00B4:  CALL   019
....................                 if (C2 == 1) { 
00B5:  BTFSS  08.1
00B6:  GOTO   0BC
....................                     while (C2 == 1);  // Wait for the key to be released 
00B7:  BTFSC  08.1
00B8:  GOTO   0B7
....................                     return '0'; 
00B9:  MOVLW  30
00BA:  MOVWF  78
00BB:  GOTO   0C9
....................                 } 
....................             } 
....................             if (C3 == 1) { 
00BC:  BTFSS  08.2
00BD:  GOTO   0C6
....................                 debounce(); 
00BE:  CALL   019
....................                 if (C3 == 1) { 
00BF:  BTFSS  08.2
00C0:  GOTO   0C6
....................                     while (C3 == 1);  // Wait for the key to be released 
00C1:  BTFSC  08.2
00C2:  GOTO   0C1
....................                     return '#'; 
00C3:  MOVLW  23
00C4:  MOVWF  78
00C5:  GOTO   0C9
....................                 } 
....................             } 
00C6:  GOTO   03E
....................         } 
....................     } 
....................     return '\0';  // Default return to avoid warning 
00C7:  MOVLW  00
00C8:  MOVWF  78
00C9:  BCF    0A.3
00CA:  BCF    0A.4
00CB:  GOTO   1CD (RETURN)
.................... } 
....................  
.................... void debounce() { 
....................     delay_ms(50);  // Simple debounce delay, adjust as needed 
*
0019:  MOVLW  32
001A:  MOVWF  5A
001B:  CALL   004
001C:  RETURN
.................... } 
....................  
.................... void check() { 
....................     flag = count = 0; 
*
00DB:  CLRF   55
00DC:  MOVF   55,W
00DD:  MOVWF  53
....................     j = strcmp(pswd, password);  // Comparison of input and predefined password 
00DE:  CLRF   58
00DF:  MOVLW  27
00E0:  MOVWF  57
00E1:  CLRF   5A
00E2:  MOVLW  22
00E3:  MOVWF  59
*
0127:  MOVF   78,W
0128:  MOVWF  56
....................     if (j == 0) { 
0129:  MOVF   56,F
012A:  BTFSS  03.2
012B:  GOTO   146
....................         //output_c(0b00000100); 
....................        // relay = 1;  // Turning relay on 
....................         display(0x01, 0); 
012C:  MOVLW  01
012D:  MOVWF  58
012E:  CLRF   59
012F:  CALL   0CC
....................         display(0x80, 0); 
0130:  MOVLW  80
0131:  MOVWF  58
0132:  CLRF   59
0133:  CALL   0CC
....................         for (i = 0; i <= 6; i++) { 
0134:  CLRF   54
0135:  MOVF   54,W
0136:  SUBLW  06
0137:  BTFSS  03.0
0138:  GOTO   145
....................             display(welcome_msg[i], 1); 
0139:  MOVLW  3B
013A:  ADDWF  54,W
013B:  MOVWF  04
013C:  BCF    03.7
013D:  MOVF   00,W
013E:  MOVWF  57
013F:  MOVWF  58
0140:  MOVLW  01
0141:  MOVWF  59
0142:  CALL   0CC
0143:  INCF   54,F
0144:  GOTO   135
....................              
....................         } 
....................     } else { 
0145:  GOTO   160
....................         relay = 0; 
0146:  BCF    07.2
....................         display(0x01, 0); 
0147:  MOVLW  01
0148:  MOVWF  58
0149:  CLRF   59
014A:  CALL   0CC
....................         display(0x80, 0); 
014B:  MOVLW  80
014C:  MOVWF  58
014D:  CLRF   59
014E:  CALL   0CC
....................         for (i = 0; i <= 13; i++) { 
014F:  CLRF   54
0150:  MOVF   54,W
0151:  SUBLW  0D
0152:  BTFSS  03.0
0153:  GOTO   160
....................             display(close_msg[i], 1); 
0154:  MOVLW  43
0155:  ADDWF  54,W
0156:  MOVWF  04
0157:  BCF    03.7
0158:  MOVF   00,W
0159:  MOVWF  57
015A:  MOVWF  58
015B:  MOVLW  01
015C:  MOVWF  59
015D:  CALL   0CC
015E:  INCF   54,F
015F:  GOTO   150
....................         } 
....................     } 
0160:  BCF    0A.3
0161:  BCF    0A.4
0162:  GOTO   21A (RETURN)
.................... } 
....................  

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
